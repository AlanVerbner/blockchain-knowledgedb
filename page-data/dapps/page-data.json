{"componentChunkName":"component---node-modules-gatsby-theme-kb-src-templates-topic-js","path":"/dapps","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"DApps\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Bonding-Curves\",\n    \"title\": \"Bonding Curves\"\n  }, \"[[Bonding Curves]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"","private":false},"outboundReferences":[{"contextLine":"- [[Bonding Curves]]","targetAnchor":null,"refWord":"Bonding Curves","target":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Bonding Curves\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\u26A0 TODO: This is a WIP, I'm still learning about this\")), mdx(\"p\", null, \"Recently - yes a little bit late \\uFE0F\\uD83E\\uDD26\\u200D\\u2640\\uFE0F as the concept dates from 2017 - I got curious about \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/continuous-tokens\",\n    \"title\": \"continuous tokens\"\n  }, \"[[continuous tokens]]\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/curation-markets\",\n    \"title\": \"curation markets\"\n  }, \"[[curation markets]]\"), \" due to a tweet where someone mentioned that some funds were raised to fund medical research program in exchange for a participation in the Intellectual Property rights. Going down the rabbit hole I found \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/@simondlr/tokens-2-0-curved-token-bonding-in-curation-markets-1764a2e0bee5\"\n  }, \"this article\"), \" written by Simon de la Rouviere which leds to this page as the main concept behind them are Bonding Curves.\"), mdx(\"p\", null, \"Bonding curves are an interesting construction with multiple use cases being automatic market making the most common one. One of the first DApps that introduced this concepts (at least as far as I remember, but I would need to do more research) is \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://bancor.network/\"\n  }, \"Bancor\"), \".\"), mdx(\"p\", null, \"A high level explainer would be: \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"There is a curve (linear, quadratic, exponential) that defines a relationship between price and token supply.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Given an \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"A\"), \" amount of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"TokenA\"), \" the contract would mint or return an amount \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"B\"), \" of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"TokenB\"), \" such that the the price is determined by this curve. For example: \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If the curve is \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y = m * x\\xB2\"), \" where\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"y = token price\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"x = token supply\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"n = exponent parameter\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"m = slope parameter\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When someone deposits the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"A\"), \" will get in return as much as \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"B\"), \" tokens based on the pricing defined by the curve or, in other words, the buying / selling price is determined by the defined curve.\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"As the curves are continuous and every time someone is buying or selling the price changes \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"a little bit\"), \" the way to determine the amount of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"TokensA\"), \" required to buy \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"TokensB\"), \" (or the other way around) requires to calculate the area under the curve, ie the integral. Implementing this process in solidity is not trivial and Bancor has defined something named Connector Weight which is an equivalent way to get the same result. \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://billyrennekamp.medium.com/converting-between-bancor-and-bonding-curve-price-formulas-9c11309062f5\"\n  }, \"This\"), \" is a really good reading material.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Picking a different curve shape makes the price evolve differently achieving different goals, for example, making the price to react faster (exponential), to have a cap (logarithmic). More examples can be found \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://medium.com/thoughtchains/on-single-bonding-curves-for-continuous-token-models-a167f5ffef89\"\n  }, \"here\"))), mdx(\"p\", null, \"As mentioned before, one of the most straightforward use cases is automatic market making, ie, there is a contract that's always willing to buy and sell at the current price. But there are other interesting ways to take advantages of this mechanism, for example, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/curation-markets\",\n    \"title\": \"curation markets\"\n  }, \"[[curation markets]]\"), \" to measure users interest or \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://ethresear.ch/t/explanation-of-daicos/465\"\n  }, \"DAICOs\"), \" to raise fund for a specific project. \"), mdx(\"h2\", null, \"Reading material\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://yos.io/2018/11/10/bonding-curves/\"\n  }, \"An excellent bonding curve explainer\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/AragonBlack/fundraising/blob/master/docs/untitled-1.md\"\n  }, \"An Aragon fundraising explainer\"))), mdx(\"p\", null, \"[curation markets]\", \": curation markets.md \\\"curation markets\\\"\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"id":"489e78fd-4ae3-5d85-bdc4-9e2a2bb59b62","fields":{"slug":"/Bonding Curves","title":"Bonding Curves"}}}}],"inboundReferences":[{"contextLine":"I'll be mostly writing about anything related to blockchain technology [[Protocols]], [[DApps]] (mostly [[Solidity]] based), NFTs, Governance or anything I find worth remembering.","referrer":{"parent":{"id":"722cd2de-f397-567f-b154-a716c9000a4a","fields":{"slug":"/readme","title":"Hi! ðŸ‘‹"}}}}]},"fields":{"slug":"/dapps","title":"DApps"}}},"pageContext":{"id":"dad61c82-7923-5dd6-982a-c504483fdaf1","refWordMdxSlugDict":{"Bonding Curves":"Bonding-Curves","curation markets":"curation-markets"}}},"staticQueryHashes":["2221750479","2380733210","2768355698","63159454","847517413"]}